package com.colin.common.async;

/**
 * 并发应用程序按照及时方式执行的能力称为活性（liveness）。一般包括三种类型的问题死锁、饿死和活锁。
 * 
 * 1、死锁
 * 线程死锁是并发程序设计中可能遇到的主要问题之一。他是指程序运行中，多个线程竞争共享资源时可能出现的一种系统状态，每个线程都被阻塞，都不会结束，进入一种永久等待状态。
 * 可能发生死锁的最典型的例子是哲学家用餐问题：五个哲学家围坐在一圆桌旁，每人的两边放着一支筷子，共5支筷子。大家边讨论问题边用餐，并规定如下条件：
 * 1）每个人只有拿起位于自己两边的筷子，合成一双才可以用餐；
 * 2）用餐后，每人必须将两支筷子放回原处。
 * 可以想想，如果每个哲学家都彬彬有礼，并且高谈阔论，轮流吃饭，则这种融洽的气氛可以长久的保持下去。
 * 但是可能出现这样一种情景：当每个人都拿起自己左手边的筷子，并同时去拿自己右手边的筷子时，5个人每人拿着一根筷子，盯着自己右手边那位哲学家手里的筷子，处于僵持状态。这就发生了线程死锁。
 * 另一个线程死锁的例子是两个朋友  A 和 B 鞠躬，都非常讲礼貌，礼貌的一个严格规则是，当你向朋友鞠躬时，必须保持鞠躬状态，直到你的朋友向你还礼。
 * 两个朋友可能同时向对方鞠躬，当朋友 A 和朋友 B 同时向对方鞠躬时，都在等待对方起身，进入阻塞状态。发生线程死锁。
 * 2、饿死
 * 饿死（starvation）描述这样的情况：一个线程不能获得对共享资源的常规访问，并且不能继续工作，当共享资源被贪婪线程长期占有而不可用时，就会发生这样的情况。
 * 3、活锁
 * 一个线程经常对另一个线程的操作作出响应，如果另一个线程的操作也对这个线程的操作作出响应，那么就可能导致活锁（livelock）。
 * 和死锁类似，发生活锁的线程不能进行进一步操作。但是，线程没有被锁定，它只是忙于相互响应，以致不能恢复工作。
 * 活锁可以比喻为两人在走廊中相遇。A 避让到自己的左边让 B 通过，而 B 同时避让到自己的右边让 A 通过。
 * 发现他们仍然挡住了对方，A 就避让到自己的右边，而 B 同时避让到了自己的左边，他们还是挡住了对方，所以就没完没了。
 * 
 * 
 * @author  colin.chen
 * @version 1.0.0
 * @date    2018年9月12日 下午1:19:41
 */
public class LivenessTest {

}
