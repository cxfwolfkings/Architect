package com.colin.common.async;

/**
 * 任何被不同线程所共享的可变值应该总是被同步的访问以防止发生干扰，然而同步是需要代价的。 Java
 * 可以保证对任何变量的读写都是原子性的，原子（atomic）操作是必须同时完成的操作，这样变量就只会持有某个线程写入的值，
 * 而绝不会持有两个不同线程写入的部分交叉混合的值。
 * 这意味着原子变量只能有一个线程来写，多个线程来读，因此不需要对他的访问进行同步以防止数据被破坏，因为这些访问之间不存在互相干扰的可能性。
 * 但这对“获取-修改-设置”（如++操作）没有任何帮助，这种操作需要同步。
 * 
 * 需要注意的是，原子访问并不能保证线程总是会读取变量最近的写入值，如果没有同步，一个线程的写入值对另一个线程可能永远都不会是可见的。
 * 有很多因素会影响一个线程写入的变量何时会对另一个线程变为可见的。当缺乏同步机制时，不同线程发现被更新变量的顺序也可以完全不同。
 * 
 * 在确定内存访问如何排序以及何时可以确保他们可见时所使用的规则被称为Java 编程语言的内存模型。
 * 
 * 线程所读取的所有变量的值都是由内存模型来决定的，因为内存模型定义了变量被读取时允许返回的值集合。
 * 从程序员的角度看，这个值集合应该只包含单一的值，即由某个线程最近写入的值。然而在缺乏同步时，实际获得的值集合可能包含许多不同的值。
 * 
 * @author colin.chen
 * @version 1.0.0
 * @date 2018年9月12日 上午10:56:39
 */
public class VolatileTest {

}

/**
 * 假设 BankAccount 中的字段 balance 可以被一个线程不断的显示，并且可以由其他线程使用非同步的方法对其进行修改。
 * 当第一次进行循环时，balance 唯一可能的值是10，由于没有使用线程同步，所以每当由线程调用 updateBalance 时，都会有新值被添加到所要读取的可能值集合中。
 * 当在循环中读取 balance 时，可能值也许已经包含了10，20，25，35 和78，其中任何一个值都可以通过读取操作返回，因为根据内存模型的规则，任何被某个线程写入的值都可以通过读取操作返回。
 * 实际上，如果 showValue 无法改变 balance 的值，那么编译器就会假设它可以认为 balance 在循环体内未发生改变，从而在每次调用 showValue 时直接使用常量10来表示 balance。
 * 这种策略和内存模型是一致的。内存模型没有控制要返回哪一个值。
 * 为了让程序能像我们所描述的那样运行，我们必须使得在写入 balance 时，写入值可以成为内存模型唯一允许读取的值。要做到这一点，必须对写入和读取的操作进行同步。
 * Java 提供了一种同步机制，它不提供对锁的独占访问，但同样可以确保对变量的每一个读取操作都返回最近写入的值，这种机制就是使用 volatile 变量。
 * 字段变量可以用修饰符 volatile 来声明，volatile 变量的写入操作将与随后所有这个变量的读取操作进行同步。
 * 如果 balance 被声明为 volatile，那么我们所给出的示例代码就会被正确的同步，并且总是会显示最新的值。
 * volatile 变量并没有提供可以跨多个动作的原子性，经常被用作简单的标记以表示发生了某个事件，或者被用来编写无锁算法（lock-free）。
 * 将变量设置为 volatile 所产生的另一个效果就是可以确保读写操作都是原子性的。
 * @author  colin.chen
 * @version 1.0.0
 * @date    2018年9月12日 上午11:21:57
 */
class BankAccount {

	private int balance;

	/**
	 * 更新
	 */
	public void updateBalance() {
		balance = (int) (Math.random() * 100);
	}

	/**
	 * 
	 * @throws InterruptedException
	 */
	public void showValue() throws InterruptedException {
		balance = 10;
		for (;;) {
			showBalance(balance);
			Thread.sleep(1000);
		}
	}
	
	public void showBalance(int balance) {
		System.out.println(balance);
	}
}
